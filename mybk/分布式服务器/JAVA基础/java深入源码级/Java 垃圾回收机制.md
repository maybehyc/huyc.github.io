# Java 垃圾回收机制

一、Java垃圾回收简介

二、哪些内存需要回收
java堆
方法区:垃圾回收主要是回收这两部分内容：废弃常量和无用的类。对于废弃常量，主要是判断当前系统中有没有对象引用这个常量；对于无用类则比较严格，需要满足下面三个条件：
（1）该类的所有实例都已经被回收，即堆中不存在该类任何势力；
（2）加载该类的ClassLoader已经被回收；
（3）对类对应的java.lang.Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法；
满足了上面三个条件也仅仅是“可以”进行回收了，还要根据HotSpot的一些配置参数综合考虑

三、什么时候回收

对象是否存活的算法:
1.引用计数算法:给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。
缺点：很难解决对象之间相互循环引用的问题。

2.可达性分析算法:通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时（或者说从GC Roots到这个对象不可达），则证明此对象是不可用的。
可作为GC Roots的对象包括：
1）虚拟机栈（栈帧中的本地变量表）中引用的对象；
2）方法区中类静态static属性引用的对象；
3）方法区中常量final引用的对象；
4）本地方法栈中JNI（即一般说的Native方法）引用的对象；

四、如何回收
1.垃圾回收算法
标记-清除:先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
缺点：
（1）效率问题：标记和清除的两个过程效率都不高；
（2）空间问题：标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后需要分配较大对象时，无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作；

复制算法:将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存使用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
复制算法的优点：
（1）每次都是对整个半区进行内存回收，实现简单、运行也高效；
（2）在那块使用内存上进行内存分配时，不用考虑内存碎片的问题，只要移动堆顶指针，按顺序分配内存即可；
缺点：
将内存缩小为原来的一半，代价较高。

改进的收集算法:将内存划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块Survivor空间，最后清理掉Eden和刚才用过的Survivor空间，清理完成后，刚刚被清理的Eden和另一块在回收时放入存活对象的Survivor空间作为使用内存，刚被清理的Survivor作为保留空间，以便后面用来回收之用。

标记-整理算法:标记过程仍然与“标记-清除”算法中一样，但是在标记完成后并不直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

分代收集算法:根据对象存活周期的不同将内存划分为几块，一般是把java堆分为新生代和老年代，根据各个年代的特点选用不同的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，因此可以选用“复制算法”，此时只需要付出少量存活对象的复制成本即可；对于老年代，因为对象存活率较高、也没有额外空间为期分配担保，就必须使用“标记-清除”或“标记-整理”算法来进行回收。

2.垃圾回收器
七种垃圾回收器
Serial、ParNew、Parallel Scavenge属于新生代收集器，CMS、Serial Old、Parallel Old属于老年代收集器，G1是最新的一种收集器，在新生代和老年代中都可使用。
新生代采用的是“复制算法”，老年代采用的是“标记-整理”算法。

(1)Serial（串行）收集器
这个收集器是一个单线程的收集器，只使用一个CPU或一条收集线程去完成垃圾收集工作。
优点: 简单而高效，没有线程交互的开销。
缺点:在它进行垃圾收集的时候，必须暂停其他所有的工作线程，直到它收集结束。

(2)ParNew收集器
是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其他行为和Serial收集器一样。
ParNew是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关的重要原因，除了Serial收集器外，目前只有ParNew能与老年代的CMS收集器配合使用。

(3)Parallel Scavenge收集器
Parallel Scavenge收集器使用的是复制算法，也是一个并行的多线程收集器。和ParNew相似，但是Parallel Scavenge的关注点不同，CMS收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量，吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。

(4)Serial Old收集器
Serial Old收集器是新生代Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理”算法，Serial Old的主要意义也是在于给Client模式下的虚拟机使用。

(5)Parallel Old收集器
Parallel Old是新生代收集器Prarllel Scavenge的老年代版本，使用多线程和“标记-整理”算法。

(6)CMS收集器
CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。对于互联网站或者B/S系统的这种注重响应速度的服务端来说，CMS是很好的选择。CMS是基于“标记-清除”算法实现的。
优点：并发收集、低停顿。
缺点：
（a）对CPU资源非常敏感，面向并发设计程序的通病，虽然不至于导致用户线程停顿，但是会降低吞吐率；
（b）无法清理“浮动垃圾”，由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断出现，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次的GC；
（c）会产生大量空间碎片，因为CMS是基于“标记-清除”算法，这种算法的最大缺点就是会产生大量空间碎片，给分配大对象带来麻烦，不得不提前触发Full GC。为了解决这个问题，CMS提供了一个“-XX:+UseCMSCompaceAtFullCollection”的开关参数（默认开启），用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程。

(7)G1收集器
G1收集器是最新的一款收集器，JDK1.7才发布，是一种面向服务端应用的垃圾收集器。
特点：
（a）并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间；
（b）分代收集：分代概念在G1中依然得以保留。虽然G1可以不需其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果；
（c）空间整合：与CMS的“标记-清理”算法不同，G1从整体看来是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上看是基于“复制”算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存；
（d）可预测的停顿时间。


