# ST

J2SE基础

1. 九种基本数据类型的大小，以及他们的封装类。
java提供了一组基本数据类型，包括
boolean, byte, char, short,  int, long, float, double, void. 

同时，java也提供了这些类型的封装类，分别为
Boolean, Byte, Character, Short, Integer, Long, Float, Double, Void

2. Switch能否用string做参数？
在jdk 7 之前，switch 只能支持 byte、short、char、int 这几个基本数据类型和其对应的封装类型。switch后面的括号里面只能放int类型的值，但由于byte，short，char类型，它们会 自动 转换为int类型（精精度小的向大的转化），所以它们也支持。
注意，对于精度比int大的类型，比如long、float，doulble，不会自动转换为int，如果想使用，就必须强转为int，如(int)float;

jdk1.7后，整形，枚举类型，boolean，字符串都可以。
为什么jdk1.7后又可以用string类型作为switch参数呢？

其实，jdk1.7并没有新的指令来处理switch string，而是通过调用switch中string.hashCode,将string转换为int从而进行判断。

3. equals与==的区别。
“==” 比较的是两个引用在内存中指向的是不是同一对象（即同一内存空间），也就是说在内存空间中的存储位置是否一致。
如果两个对象的引用相同时（指向同一对象时），“==”操作符返回true，否则返回flase。

equals方法是由Object类提供的，可以由子类来进行重写

4. Object有哪些公用方法？
clone方法

保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。

主要是JAVA里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递，我们有时候不希望在方法里讲参数改变，这是就需要在类中复写clone方法。

getClass方法

final方法，获得运行时类型。

toString方法

该方法用得比较多，一般子类都有覆盖。

finalize方法

该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。

equals方法

该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。

hashCode方法

该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。

一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。

如果不重写hashcode(),在HashSet中添加两个equals的对象，会将两个对象都加入进去。

wait方法

wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。

调用该方法后当前线程进入睡眠状态，直到以下事件发生。

（1）其他线程调用了该对象的notify方法。

（2）其他线程调用了该对象的notifyAll方法。

（3）其他线程调用了interrupt中断该线程。

（4）时间间隔到了。

此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。

notify方法

该方法唤醒在该对象上等待的某个线程。

notifyAll方法

该方法唤醒在该对象上等待的所有线程

5. Java的四种引用，强弱软虚，用到的场景。
强引用（StrongReference）
强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。
Object o=new Object();   //  强引用

软引用（SoftReference）
如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
String str=new String("abc");                                     // 强引用
SoftReference<String> softRef=new SoftReference<String>(str);     // 软引用

弱引用（WeakReference）
弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。
String str=new String("abc");    
WeakReference<String> abcWeakRef = new WeakReference<String>(str);
str=null;

虚引用（PhantomReference）
“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

Java4种引用的级别由高到低依次为：

强引用  >  软引用  >  弱引用  >  虚引用

6. Hashcode的作用。
HashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，HashCode经常用于确定对象的存储地址；

7. ArrayList、LinkedList、Vector的区别。
ArrayList、LinkedList和Vector都是实现了List接口。

其中，ArrayList和Vector底层是用数组实现的，因此可以用序号下标来访问他们，查找的效率高，一般数组的大小比要插入的数据大数量要大。

LinkedList的底层使用双向链表实现的，因此插入和删除的效率高。

在多线程并发的时候，ArrayList和LinkedList是非线程安全的，并且是不同步的。Vector的所有方法都用了synchronized方法，是线程安全的，但是vector中的方法组合起来使用不是线程安全的。

8. String、StringBuffer与StringBuilder的区别。
可变与不可变
　　String类中使用字符数组保存字符串，如下就是，因为有“final”修饰符，所以可以知道string对象是不可变的。
　　　　　　private final char value[];　
　　StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，如下就是，可知这两种对象都是可变的。
　　　         char[] value;
　　　         
是否多线程安全
　   String中的对象是不可变的，也就可以理解为常量，显然线程安全。
　   AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。
　   StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。
　   StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。
　   　
9. Map、Set、List、Queue、Stack的特点与用法。

10. HashMap和HashTable的区别。
HashMap中键值 允许为空 并且是非同步的
Hashtable中键值 不允许为空 是同步的
继承不同，但都实现了Map接口
　　　　　
11. HashMap和ConcurrentHashMap的区别，HashMap的底层源码。
Hashmap本质是数组加链表。根据key取得hash值，然后计算出数组下标，如果多个key对应到同一个下标，就用链表串起来，新插入的在前面。

ConcurrentHashMap：在hashMap的基础上，ConcurrentHashMap将数据分为多个segment，默认16个（concurrency level），然后每次操作对一个segment加锁，避免多线程锁的几率，提高并发效率。
　　
12. TreeMap、HashMap、LindedHashMap的区别。
LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列，像连接池中可以应用。
TreeMap就是一个红黑树的结构，每个key-value对作为红黑树的一个节点。存储key-value对的时候要根据key对节点进行排序。TreeMap可以保证key-value对处于有序状态。
WeakHashMap与HashMap的区别是，HashMap的key保留了对实际对象的强引用，也就是说，只要HashMap对象不销毁，HashMap所引用的对象就不会被垃圾回收，也不会自动删除这些key所对应的key-value对；但是WeakHashMap的key只保留对实际对象的弱引用。

13. Collection包结构，与Collections的区别。
java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。
java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。

14. try catch finally，try里有return，finally还执行么？
会执行。finally{}块的代码只有在try{}块中包含遇到System.exit(0);之类的导致Java虚拟机直接退出的语句才会不执行。

当程序执行try{}遇到return时，程序会先执行return语句，但并不会立即返回——也就是把return语句要做的一切事情都准备好，也就是在将要返回、但并未返回的时候，程序把执行流程转去执行finally块，当finally块执行完成后就直接返回刚才return语句已经准备好的结果。

15. Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。
Throwable包含两个子类：Error和Excaption。他们通常用于指示发生了异常情况。

OOM
OutOfMemoryError异常

除了程序计数器外，虚拟机内存的其他几个运行区域都有发生OutOfMemoryError(OOM)异常的可能。

java Heap 溢出

一般的异常信息：java.lang.OutOfMemoryError:Java heap spacess

java堆用于存储对象实例，我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制来清除这些对象，就会在对象到达最大堆容量限制后产生内存溢出异常。

出现这种异常，一般手段通过内存影响分析工具（如Eclipse Memory Analyzer）对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否必要，先分清是因为内存泄漏（Memory Leak : 内存泄漏也称作"存储渗漏"，用[动态存储]分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束。(其实说白了就是该内存空间使用完毕之后未回收)即所谓内存泄漏。）还是内存溢出（Memory Overflow）。

如果是内存泄漏，引用可进一步通过工具查看泄漏对象到GC Roots的链。于是就能找到泄露对象时是通过怎样的途径导致垃圾收集器无法自动回收。

如果不存在内存泄漏，那就应该检查虚拟机的参数（-Xmx与-Xms）的设置是否适当。

2.虚拟机栈和本地方法栈溢出

如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。

如果虚拟机无法申请到足够的内存空间，则抛出OutOfMemeryError异常

这里需要注意当栈的大小越大，可分配的线程就越小。

3、运行时常量池溢出

异常信息：java.lang.OutOfMemoryError:PermGen space

如果要向运行时常量池中添加内容，最简单的做法是使用String.interm()这个Native方法。该方法的作用是：如果池中已经包含了一个等于此String的字符串，则返回代表池中这个字符串的String对象，否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。

4、方法区溢出

方法区用于存放Class的相关信息、如类名、访问修饰符、常量池、字段描述、方法描述等。

异常信息：java.lang.OutOfMemoryError:PermGen space

方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的，经常动态生成的大量的Class的应用中，要特别注意这点。

SOF

程序中一旦出现死循环或者是大量的递归调用，在不断压栈过程中，造成栈容量超过默认大小而导致溢出。

栈溢出的原因：

递归调用
大量循环或死循环
全局变量是否过多
数组、List 、map数据过

16. Java面向对象的三个特征与含义。

17. Override和Overload的含义去区别。
Override 重写  Overload 重载

18. Interface与abstract类的区别。
Interface 接口  abstract 抽象类

19. Static class 与non static class的区别。
static class
a、用static修饰的是内部类，此时这个
内部类变为静态内部类；对测试有用；
b、内部静态类不需要有指向外部类的引用；
c、静态类只能访问外部类的静态成员，不能访问外部类的非静态成员；

non static class
a、非静态内部类需要持有对外部类的引用；
b、非静态内部类能够访问外部类的静态和非静态成员；
c、一个非静态内部类不能脱离外部类实体被创建；
d、一个非静态内部类可以访问外部类的数据和方法；

20. java多态的实现原理。

21. 实现多线程的两种方法：Thread与Runable。

22. 线程同步的方法：sychronized、lock、reentrantLock等。

23. 锁的等级：方法锁、对象锁、类锁。

24. 写出生产者消费者模式。

25. ThreadLocal的设计理念与作用。
每个线程中都会维护一个ThreadLocalMap，当在某个线程中访问时，会取出这个线程自己的Map并且用当前ThreadLocal对象做索引来取出相对应的Value值，从而达到不同线程不同值的效果。

26. ThreadPool用法与优势。
合理利用线程池能够带来三个好处。第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。

27. Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。

28. wait()和sleep()的区别。
sleep()方法属于Thread类中的。而wait()方法，则是属于Object类中的

sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。
在调用sleep()方法的过程中，线程不会释放对象锁。

而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备

29. foreach与正常for循环效率对比。
需要循环数组结构的数据时，建议使用普通for循环，因为for循环采用下标访问，对于数组结构的数据来说，采用下标访问比较好。

需要循环链表结构的数据时，一定不要使用普通for循环，这种做法很糟糕，数据量大的时候有可能会导致系统崩溃。

30. Java IO与NIO。
Buffer和Channel是标准NIO中的核心对象（网络NIO中还有个Selector核心对象)

31. 反射的作用于原理。

32. 泛型常用特点，List<String>能否转为List<Object>。
不能
List<Object> 这里面的类型Object并不是一个泛型,也不是作为一个所有类型的父类，仅仅只是一个具体的Object类而已，所以arrayList集合中实体的类型必须要是Object类型才行。而如果把List<Object>改为泛型List<T>的话就完美解决，它可以允许arrayList集合种类型为类和类型而无限制。

33. 解析XML的几种方式的原理与特点：DOM、SAX、PULL。

34. Java与C++对比。

35. Java1.7与1.8新特性。

36. 设计模式：单例、工厂、适配器、责任链、观察者等等。

37. JNI的使用。

Java里有很多很杂的东西，有时候需要你阅读源码，大多数可能书里面讲的不是太清楚，需要你在网上寻找答案。

推荐书籍：《java核心技术卷I》《Thinking in java》《java并发编程》《effictive java》《大话设计模式》

JVM

1. 内存模型以及分区，需要详细到每个区放什么。
栈区: 线程私有，生命周期与线程相同。每个方法执行的时候都会创建一个栈帧（stack frame）用于存放 局部变量表、操作栈、动态链接、方法出口。

堆区: 存放对象实例，所有的对象的内存都在这里分配。垃圾回收主要就是作用于这里的。

方法区: 类型信息、字段信息、方法信息、其他信息.

程序计数器: 这里记录了线程执行的字节码的行号，在分支、循环、跳转、异常、线程恢复等都依赖这个计数器。

本地方法栈: 执行本地方法（Native Method）服务

2. 堆里面的分区：Eden，survival from to，老年代，各自的特点。
a、新生代又分为 Eden区、ServivorFrom、ServivorTo三个区。
Eden区：Java新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行一次垃圾回收。
ServivorTo：保留了一次MinorGC过程中的幸存者。
ServivorFrom：上一次GC的幸存者，作为这一次GC的被扫描者。

MinorGC的过程：MinorGC采用复制算法。首先，把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果ServicorTo不够位置了就放到老年区）；然后，清空Eden和ServicorFrom中的对象；最后，ServicorTo和ServicorFrom互换，原ServicorTo成为下一次GC时的ServicorFrom区。

b、老年代：主要存放应用程序中生命周期长的内存对象。

老年代的对象比较稳定，所以MajorGC不会频繁执行。在进行MajorGC前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间。

MajorGC采用标记—清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC的耗时比较长，因为要扫描再回收。MajorGC会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。

当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常。

c、永久代

指内存的永久保存区域，主要存放Class和Meta（元数据）的信息,Class在被加载的时候被放入永久区域. 它和和存放实例的区域不同,GC不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常。

在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。

元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory, 字符串池和类的静态变量放入java堆中. 这样可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制.

采用元空间而不用永久代的几点原因：（参考：http://www.cnblogs.com/paddix/p/5309550.html）

　　为了解决永久代的OOM问题，元数据和class对象存在永久代中，容易出现性能问题和内存溢出。
　　类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出（因为堆空间有限，此消彼长）。
　　永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
　　Oracle 可能会将HotSpot 与 JRockit 合二为一。
　　
3. 对象创建方法，对象的内存分配，对象的访问定位。
对象创建方法: https://www.cnblogs.com/tf-Y/p/5264809.html
对象的内存分配:
指针碰撞：假设Java堆中内存是绝对规整的，所有用过的内存放在一边，空闲的内存在另一边，中间放着一个指针作为分界的指示器，那么当分配内存时仅需移动指针即可。
空闲列表：维护一个列表，记录那些内存可用，分配时找出一块足够大的空间进行划分，并更新列表记录。
选择：分配方式的选择依赖于内存大小是否规整，内存大小的规整，依赖于垃圾收集器是否带有压缩整理功能。　　

4. GC的两种判定方法：引用计数与引用链。
引用计数法是垃圾收集的早期策略，在这中方法中，堆中每个对象都有一个引用计数，每当有一个地方引用他时，引用计数值就+1,当引用失效时，引用计数值就-1，任何时刻引用计数值为0的对象就是可以被回收，当一个对象被垃圾收集时，被它引用 的对象引用计数值就-1，所以在这种方法中一个对象被垃圾收集会导致后续其他对象的垃圾收集行动。
优点：判定效率高；
缺点：不完全准确，当两个对象相互引用的时候就无法回收，导致内存泄漏。

可达性分析算法
这个算法的基本思路就是通过一系列名为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

在Java语言里，可作为GC Roots对象的包括如下几种：
a.虚拟机栈(栈桢中的本地变量表)中的引用的对象
b.方法区中的类静态属性引用的对象
c.方法区中的常量引用的对象
d.本地方法栈中JNI的引用的对象 

5. GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？
标记-清除法：
就是先标记哪些对象实例不用，然后直接清除。缺点就是产生大量的内存碎片，下次若要存储一个大的对象，无法找到连续内存而又必须提前GC。
复制算法：
即把内存分成相等的AB两块，每次只使用其中的一块。比如当A内存使用完后，就把A中还存活着的对象复制到另外一块内存中去（B），然后再把已经使用过的内存清理掉。优点：这样就不用考虑内存碎片的问题了。缺点：内存减半，代价略高。
标记-整理法：
复制算法当存活的实例多的时候，就需要大量复制，效率不高，不适合老生代这种。那么就可以采用标记-整理算法。也就是先标记，然后对存活的对象进行移动，全部移动到一端，然后再对其它的内存进行清理。

优化收集方法 属于JVM调优,待。。。
https://blog.csdn.net/zdy0_2004/article/details/43030659

6. GC收集器有哪些？CMS收集器与G1收集器的特点。
serial收集器
parnew收集器
parallel scavenge收集器
serial old收集器
parallel old收集器
CMS收集器
CMS的适用特点：
希望JAVA垃圾回收器回收垃圾的时间尽可能短；
应用运行在多CPU的机器上，有足够的CPU资源；
有比较多生命周期长的对象；
希望应用的响应时间短。

G1收集器
G1的特点：
利用多CPU来缩短STW的时间
可以独立管理整个堆（使用分代算法）
整体是基于标记-整理，局部使用复制算法，不会产生碎片空间
可以预测停顿：G1吧整个堆分成多个Region，然后计算每个Region里面的垃圾大小（根据回收所获得的空间大小和回收所需要的时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。

7. Minor GC与Full GC分别在什么时候发生？
Major GC 是清理永久代。
Full GC 是清理整个堆空间—包括年轻代和永久代

8. 几种常用的内存调试工具：jmap、jstack、jconsole。

9. 类加载的五个过程：加载、验证、准备、解析、初始化。
加载：根据查找路径找到相应的class文件，然后导入。
检查：检查夹加载的class文件的正确性。
准备；给类中的静态变量分配内存空间。
解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址。
初始化：对静态变量和静态代码块执行初始化工作。

10. 双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、ApplicationClassLoader。
如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。

11. 分派：静态分派与动态分派。
静态分派: 在编译期间，可以根据变量的静态类型确定方法执行版本的分派动作称作静态分派。典型的是方法的重载。
动态分派: 在编译期间确定不下来，只有在方法调用时，根据对象的实际类型确定方法执行版本的分派动作称作动态分派。 重写。

JVM过去过来就问了这么些问题，没怎么变，内存模型和GC算法这块问得比较多，可以在网上多找几篇博客来看看。

推荐书籍：《深入理解java虚拟机》

数据结构与算法

1. 链表与数组。

2. 队列和栈，出栈与入栈。

3. 链表的删除、插入、反向。

4. 字符串操作。

5. Hash表的hash函数，冲突解决方法有哪些。

6. 各种排序：冒泡、选择、插入、希尔、归并、快排、堆排、桶排、基数的原理、平均时间复杂度、最坏时间复杂度、空间复杂度、是否稳定。

冒泡:
比较相邻的元素。如果第一个比第二个大，就交换他们两个。
对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
针对所有的元素重复以上的步骤，除了最后一个。
持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

时间复杂度: O(n^2)

选择:
初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

时间复杂度: O(n^2)

插入:
通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

时间复杂度: O(n^2)

希尔(分组的插入排序):
https://www.cnblogs.com/ronnydm/p/5905715.html

归并:

堆排(堆数据结构):
将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了

7. 快排的partition函数与归并的Merge函数。

8. 对冒泡与快排的改进。

9. 二分查找，与变种二分查找。

10. 二叉树、B+树、AVL树、红黑树、哈夫曼树。

11. 二叉树的前中后续遍历：递归与非递归写法，层序遍历算法。

12. 图的BFS与DFS算法，最小生成树prim算法与最短路径Dijkstra算法。

13. KMP算法。

14. 排列组合问题。

15. 动态规划、贪心算法、分治算法。（一般不会问到）

16. 大数据处理：类似10亿条数据找出最大的1000个数………等等

算法的话其实是个重点，因为最后都是要你写代码，所以算法还是需要花不少时间准备，这里有太多算法题，写不全，我的建议是没事多在OJ上刷刷题（牛客网、leetcode等），剑指offer上的算法要能理解并自己写出来，编程之美也推荐看一看。

推荐书籍：《大话数据结构》《剑指offer》《编程之美》

Android

1. Activity与Fragment的生命周期。

2. Acitivty的四中启动模式与特点。

3. Activity缓存方法。

4. Service的生命周期，两种启动方法，有什么区别。

5. 怎么保证service不被杀死。

6. 广播的两种注册方法，有什么区别。

7. Intent的使用方法，可以传递哪些数据类型。

8. ContentProvider使用方法。

9. Thread、AsycTask、IntentService的使用场景与特点。

10. 五种布局： FrameLayout 、 LinearLayout 、 AbsoluteLayout 、 RelativeLayout 、TableLayout 各自特点及绘制效率对比。

11. Android的数据存储形式。

12. Sqlite的基本操作。

13. Android中的MVC模式。

14. Merge、ViewStub的作用。

15. Json有什么优劣势。

16. 动画有哪两类，各有什么特点？

17. Handler、Loop消息队列模型，各部分的作用。

18. 怎样退出终止App。

19. Asset目录与res目录的区别。

20. Android怎么加速启动Activity。

21. Android内存优化方法：ListView优化，及时关闭资源，图片缓存等等。

22. Android中弱引用与软引用的应用场景。

23. Bitmap的四中属性，与每种属性队形的大小。

24. View与View Group分类。自定义View过程：onMeasure()、onLayout()、onDraw()。

25. Touch事件分发机制。

26. Android长连接，怎么处理心跳机制。

27. Zygote的启动过程。

28. Android IPC:Binder原理。

29. 你用过什么框架，是否看过源码，是否知道底层原理。

30. Android5.0、6.0新特性。

Android的话，多是一些项目中的实践，使用多了，自然就知道了，还有就是多逛逛一些名人的博客，书上能讲到的东西不多。另外android底层的东西，有时间的话可以多了解一下，加分项。

推荐书籍：《疯狂android讲义》《深入理解android》

其他综合性的书籍也需要阅读，推荐：《程序员面试笔试宝典》《程序员面试金典》。另外“牛客网www.newcoder.com”是个好地方，里面有各种面试笔试题，也有自己在线的OJ，强烈推荐，还有左程云老师的算法视屏课（已经出书了），反正我看了之后对我帮助很大（这不是植入广告）。

三、 项目
1. XXX（某个比较重要的点）是怎么实现的？

2. 你在项目中遇到的最大的困难是什么，怎么解决的？

3. 项目某个部分考虑的不够全面，如果XXXX，你怎么优化？

4. XXX（一个新功能）需要实现，你有什么思路？

四、 其他

你应该问的问题

1. 贵公司一向以XXX著称，能不能说明一下公司这方面的特点？

2. 贵公司XXX业务发展很好，这是公司发展的重点么？

3. 对技术和业务怎么看？

4. 贵公司一般的团队是多大，几个人负责一个产品或者业务？

5. 贵公司的开发中是否会使用到一些最新技术？

6. 对新人有没有什么培训，会不会安排导师？

7. 对Full Stack怎么看？

8. 你觉得我有哪些需要提高的地方？

五、 面经

LZ应聘的职位都是android客户端开发。

面经其实说来话长，包括实习的话面过的公司有：CVTE、腾讯、阿里、百度、网易、蘑菇街、小米。最早得追溯到到今年3月份，那时候刚过完年，然后阿里的实习内推就开始了，我基本都没什么准备，就突如其来的接到了人生中第一个面试电话。

阿里实习内推一面： 电话面试， 由于是第一次面试，所以非常紧张，项目都没怎么说清楚。然后面试官就开始问项目细节了，这里我关于一个项目细节和面试官有不同的看法，面试官说我这样做有问题，然后我说我们确实是这样做的，并没有出什么错，差点和面试官吵起来，最后我还是妥协了。然后问了我一个怎么对传输的数据加密，我答的很挫，然后面试官就开始鄙视我：你这个基础不好，那个基础不好，那你说说你还有其他什么优势没？Blabla紧张的说了一些…………只面了30分钟不到，然后妥妥的就挂了。

经过这次面试突然感觉人生的艰辛，几天后我们教研室的其他同学陆续开始了面试，他们都很顺利，其中我的室友（单程车票）很顺利的拿到了offer，他是个大神，然后我就压力无比的大。制定了整套复习计划，从早上9点看书看到晚上10点。

到了3月15号左右有CVTE面试，第一次面试是群面，比较坑，坐了一个小时的车过去群面了5分钟，没什么好说的。

CVTE实习面 ：在自我介绍和项目后，面试官开始问一些java基础，object有哪些方法？这个还能说了一些。问hashmap有多大，这个当时一脸茫然，还sb的答了一个65535。然后面试官让我写三分钟内写一个二分查找，当时也是第一次手写代码，并且还计时，完全没经验，最后超时写了出来。中间又问了我一堆基础，都答得不是很完整。最后问我遇到过OOM的情况没有，什么情况下会OOM。这个也没答出来，然后又妥妥的挂了。

这次经历告诉我，我是缺少面试经验，和现场写代码的能力，基础还需要多加强。所以我开始各种准备，在一个月的时间里看了四本面试书（程序员面试宝典、java程序员面试宝典、程序员面试笔试宝典、剑指offer），把所有关于数据结构和算法的东西用代码写了一遍。

然后到了四月初，腾讯来了，我最开始还是非常向往腾讯的，但就当时那个情况，我对自己不报太大希望，觉得能进BAT这样的顶级公司是个奢侈的梦想。

腾讯的面试是在一个5星级酒店里面，逼格高大上，感觉问的东西也比较多，感觉喜欢问智力题，但是我没遇到。

腾讯实习1面： 50分钟左右， 面试的时候还是有些紧张的，但是运气好，遇到了一个学校的师兄，他一直叫我不要紧张。几个比较关键的问题：死锁的必要条件，怎么解决，java和c++比有什么优势，java同步方法，activity生命周期，中间让我设计了个银行排队系统，我说了一堆。然后让我写了一个计算一个int里面二进制有几个1，然后我用最高效的方法（n=n&n-1）写出来之后，面试官有点意外，还说没见过这么写的，让我跟他解释一下。后面就是拉拉家常，问我对工作地点怎么看，让我对比qq和微信，一面出来之后，面试官让我留意通知，心想是过了，其实发挥的不怎么好。

就在会学校的路上，都要到学校了，收到了腾讯二面的通知，下午3点。然后我又跑回去二面。

腾讯实习2面： 二面是一个很严肃的人，看上去就比较资深那种，一直都不笑，后面才知道是手机管家T4的专家。一开始就问我项目里，心跳包是怎么设计的，我项目里并没有用心跳，然后只能跟他说没做，问我用json传输数据有什么不好（我只知道用哪想过有什么不好）。又问了http和socket的区别，两个协议哪个更高效一点，遇到过java内存泄露没有，用过哪些调试java内存工具，java四种引用。多数都是项目上的东西，基础的东西没问太多，然后感觉自己答的不是很好，很多都不知道，而且还答错了。其实我感觉我应该是过不了的，但是最后我问问题的时候，我让他评价下我的表现，他说不好评价，我自己说了一堆，说在学校里确实见识到的东西比较少，很多东西没考虑全面，然后他表示赞同，和我探讨了一番，我觉得最后这个问题给我加了不少分。二面也面了50分钟左右。

回来后发现我的状态一直没变，而他们二面完了的都到了HR面了，我以为我已经挂定了，后来在一天晚上12点的时候，惊喜的收到了第二天HR面的短信，当晚上几乎高兴得一晚上没睡着觉。

腾讯实习3面（HR）： 就是hr面，也就面了十几分钟，聊聊天，问问哪的人，未来什么打算的等等，基本不怎么挂人就不详细写了。

就这样拿到了人生中第一个实习offer。

后面找实习的心就放松了，没有复习了。然后到了5月5号，阿里来了。对阿里也只是想去面一面的心态了，因为已经有腾讯的offer了，就没想太多。

阿里实习1面： 面过腾讯之后发现自己已经比较淡定了，面试得时候能够比较好的交谈了。这一面也遇到一个比较好的面试官，能很轻松的和他交流。主要的问题是android的：activity的生命周期、activity的四种启动模式（当时忘了一些没答全）、线性布局和相对布局、多线程请求，java GC算法与GC方法，内存模型，有一个比较特别的问题是问我微信的朋友圈怎么设计，然后我把思路跟他说了，其他的就是问了项目相关的了。还问了我一个觉得技术深度重要还是技术宽度重要，一面感觉还是比较基础的。

阿里实习2面： 这一面就比较虐心，碰到一个阿里云的CTO，一上去项目看都不看，直接问我写过多少行代码，我说至少3、4万行，然后他让我写了两个题：一个找素数，一个递归求阶层，对我也算手下留情（他后来让我同学写AVL树的插入算法，想想也是醉了）。后面就各种基础了，java的基础挨个问了一遍，比较关键多线程实现，锁的几种等级等，反射的用法，wait()和sleep()（讨论这个的时候他把我说晕了），Java还好，多数能应付，然后他就开始问c++的了。虽然是基础，但是lz忘了差不多了，什么指针数组和数组指针，虚函数，多态实现（这个我扯到java上了）等等，问了很多，很多都没答上来，然后他说我基础不太好（我想说我简历上写的了解C++，为什么要追着我问TT）。

就这样出来了，本来以为挂了，后面被通知过了。同学都只有2面技术面，我居然多了一面，叫交叉面试，心想这下肯定完了。

阿里实习3面： 这一面遇到了后面我去实习时候的部门boss，人非常好，来的时候走的时候都要和我握手，非常的平易近人。这一面还是问项目上的一些东西居多，基础就问了个java多线程，各个排序的时间复杂度、思想。技术问了半个小时，后面半个小时就开始各种聊人生了（@_@），我家是哪的，父母干嘛的，中学怎么样，大学怎么样，等等，完全就不像是技术面嘛（后来才知道，我一个同学一开始来就和他聊人生，还聊过了。再次感叹找工作是看缘分呐）。

阿里实习4面（HR） ：阿里hr比腾讯hr面专业，面了一个小时，把我的生活经历趴了一遍，（问了类似你的优缺点，最让你高兴的一件事，最让你伤心的一件事，你的职业规划，你的理想等等，这种，现在想不起来了）也没什么特别好说的。

面完后第二天去圆桌签offer，就这样又拿到了阿里的实习offer。

LZ后面衡量了杭州阿里B2B和广州腾讯MIG，最后选择去了阿里，因为在总部，感觉大boss人比较好，发展前途可能不错，而且留下来的几率比较大，而腾讯是一个分部门，感觉可能不是很有前景（但是后来了解到其实广州腾讯MIG发展前景非常好，环境也非常和谐，我同学去实习的都留下来了。哎，只能感叹选择是个大问题）。在阿里实习的两个月时间也挺愉快的，学到了不少东西，也认识了很好的师兄和主管，只因最后被拥抱了变化没有拿到正式offer。

实习面经就已经写完了，后面是正式找工作的经历，主要是内推比较多：腾讯、网易、蘑菇街、小米，校招就面了家百度。

在阿里实习的时候，面了网易和蘑菇街。

网易面试是我面了这么多中，问得最专业的了。

网易内推1面： 电话面，一天在里中午休息的时候面的。这一面我面得很烂，由于在阿里实习，面试官恰好也在阿里呆过，问了我在阿里学到了哪些东西，看过哪些框架，看过源码没有，我支支吾吾说了一些，面试官不太满意（我表示我都说不全啊，在阿里就来了不久，哪那么多时间看源码）。项目各种细节问一通之后，开始问基础，Http报文结构，Handler、Looper模型，ThreadLocal（这个LZ当时没答上来），怎么使service不被杀死，android内存优化，自己实现线程队列模型，问我怎么设计（这个当时被前面的问题问蒙了，直接说不知道了），面了20+分钟，感觉答得都不怎么好，然后面试官问我说还有没有什么比较擅长的他没有问道的，我就把android Framework里zygote的启动和Binder通信说了一遍（这里强行装了一次逼）。

面完之后本以为挂定了，然后师姐跟我说居然过了，也是够神奇，我觉得是我后面补充的内容救了我。

网易内推2面： 二面是现场面，就在阿里滨江区的隔壁。时间是一天中午，吃了饭就到了隔壁。面试官是个比较年轻人，可能大不了我几岁，也是非常好说话，开始也是聊项目，我把在阿里做的app和自己写的小框架拿出来，他就指着上面各种问，这里怎么实现，会有什么问题，你怎么解决，然后他描述了一个场景说，两个activity，前面的是个dialog activity，怎么在dialog activity存在的情况下改变后面的activity（lz答的用广播）。android怎么解决缓存，要是内存超了怎么办？然后扯到了JVM，GC判定算法与方法，哪个区域用什么GC算法，怎么改进复制算法。然后是基础，也像一面一样问了一些，hashmap和concurrntHashmap的区别、泛型能否强制转换。然后是算法，问了快排和归并的平均时间复杂度与最差时间复杂度，出了个算法题：怎么找到一个随机数组的前50大数、中间50大数，（这个用最小堆和partition函数），复杂度是多少。

面完之后其实感觉还不错，基本都打答上来了，顺利进入三面。

网易内推3面（HR）： hr面也是现场，也聊了很多，问我为什么要从阿里来网易，有什么打算，你看中网易的什么（主要是针对我是在阿里实习来问的，我就讲了一堆网易的优势），让来杭州工作愿不愿意。还跟我说了，这次内推是优中选优，有名额限制，如果没有通过，请继续关注网易校招。

后面让师姐查了下状态，状态显示是三面已通过。但是最后没有收到offer，还是有点小失望。

蘑菇街面试感觉比较基础，没有什么技术难度。

蘑菇街内推1面： 电话面，也是在一个中午面的。18分钟，问了一些项目，主要是问基础、问得非常基础：Arraylist与LinkedList区别，String与StringBuffer用法，HashMap与HashTable区别，Synchronized用法等等等等（非常基础），这不一一列举了，然后很顺利的就过了。

2面是在20天后了，也不知道蘑菇街出了什么岔子。

蘑菇街内推2面 ：也是电话面，CTO面试，就整体聊了项目，我在项目中学到了什么，遇到什么困难怎么解决的，在阿里实习学到了哪些东西，有看过源码么，我的优缺点，我为什么选择蘑菇街，我了解蘑菇街哪些东西。最后答完感觉自己答得还行但是也没有过，不知道为什么。

小米是投的内推精英计划，50个名额，解决北京户口。

小米内推1面： 电话面，大概40分钟，面试的时候那边很吵，不过幸好面试官语速慢，而且我答完一个问题后，面试官会和我交流哪里没有答好。没有问项目，就问了基础，问题也不多：HashMap删除元素的方法，for each和正常for的用在不同数据结构（ArrayList、set、hashmap）上的效率区别（LZ表示没有看过源码，不知道），static class和non-static class的区别，一个大文件几个GB，怎么实现复制（这个也没有答好）。然后问了两个算法：之前一个出现过，另一个是在Git里面，如果有n个分支，m次commit怎么找到任意两个节点共同的那个父节点（这个当时我想错了，想到二叉树上去了，没有答好）。然后让两个算法用代码实现，1个小时内写好email给他。

小米面了以后也杳无音信，估计也是要求很高，毕竟解决北京户口。

其实在阿里实习的时候很早就开始投简历了，因为出去实习一段时间后，感觉还是很想留在成都（因为lz是四川人）。腾讯我没有参加校招面试，直接走的内推流程。

腾讯1面： 电话面，7月20+号，很水，就问了项目，聊了可能有十多分钟，然后面试官说，内推没有什么作用，还是要走校招面试（我觉得他可能是有其他事情，想节省时间），你在实习不能回来，还是要现场面一次才行，然后就留了个电话让我校招联系他，这样就完了。

2面是在我回学校后了。

腾讯2面： 9月6号我回学校之后，下午3点接到电话，让我晚上7点去腾讯现场面的（我在想为何是在晚上，lz学校到腾讯要2个小时，还让不让人回来了），当时紧张得要死，因为刚从阿里回来不久，都没怎么好好准备基础，在地铁上看了两本基础书，亚历山大。面试是在腾讯里面，微信部门，面试官是个中年人（现在是LZ的主管），看起来还是比较沉稳的那种。也没问基础技术问题，就聊项目细节和一些可优化的地方，然后把lz的简历看了翻了一遍，问了一遍，然后就是问我在阿里学到了什么，为什么当时选择了阿里（这时候肯定要各种跪舔啊）。然后后来他说他是做iOS的，我在想难怪不问我基础。

面完了说一周之内通知我结果，也没报太大希望，感觉并不太对口，因为搞不懂为什么是做ios的来面我。

两天之后，在阿里HRG电话通知我拥抱变化之后，几乎同一时间，腾讯电话通知我拿到了成都offer，我只能感叹太巧了（大概这大半辈子的运气都花光了）。

后来校招开始后，只面了百度一家公司，百度确实比较重视基础与算法，看中技术。

百度1面： 大概1个小时，又是个做ios的师兄面试我，自然就只能聊项目了，我给他展示了我做的app后，也问了些技术问题，缓存怎么做的，内存溢出怎么处理。然后两个算法题：把一个数组中奇数放前面，偶数放后面，这个要求写出来。另一个是3亿条IP中，怎么找到次数出现最多的5000条IP。最后问了是否愿意去北京，对于技术的看法。

百度2面： 50分钟，写个4个程序题：反转链表、冒泡排序、生产者消费者，这三个都还好写，很快的写出来了，还有一个题是在一组排序数中，给定一个数，返回最接近且不大于这个数的位置，要求时间在O(logn)（这个想了一会，用二分查找，然后特殊处理了一下），最后他看不懂，要我一步一步解释。花了好一整子，最后问了个java反射，就让我走了。百度果然是重视算法。

百度3面： 这一面应该是个技术高层，笼统的问了我一下项目的问题，然后问了几个基础：java反射机制；android动画有哪些，什么特点？TCP/IP层次架构，每层的作用与协议；TCP拥塞控制；滑动窗口是怎么设计的，有什么好处；android的布局都有哪些。问完这些之后，然后就是有点类似于HR的聊天了：如果这次面试过了你觉得是因为什么原因，没过呢？你觉得百度怎么样？你对技术路线什么打算？有些和前面重复的就不写了。然后他让我问他问题，我就连续问了5、6个问题，最后愉快的走了。

